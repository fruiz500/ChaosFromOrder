<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" manifest="snakeacci.appcache">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Snakeacci encryption</title>
<meta name="Keywords" content="passlok, URSA, one-time pad, browser, encryption, decryption, symmetric, signature, javascript, PGP, PRISM, running-key">
<meta name="Description" content="Snakeacci encryption">
<meta name="author" content="F. Ruiz">
<meta name="robots" content="index">
<meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<link rel="apple-touch-icon" href="tripletext-touch-icon.png">

<!--CSS stylesheet containing the Light color scheme-->
<style>
html {
	-webkit-text-size-adjust: 100%;
	overflow-y: scroll;
}
body {
	font-family: Sans-Serif;
	font-size: large;
	margin-left: 1%;
	margin-right: 1%;
	overflow: auto;
	background-color: #FFFFFF;
	color: #000000;
}
.cssbutton {
	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	border-radius: 10px;
	font-family: Arial;
	font-size: 22px;
	padding: 10px;
	text-decoration: none;
	border: 0px;
	margin-right: -2px;
	color: #666666;
	background: #e6e6e6;
}
.cssbutton:hover {
	text-decoration: none;
	cursor: pointer;
	background: #d8d8d8;
}
.cssbutton:disabled {
	color: #b7b7b7;
	background: #f4f4f4;
	cursor: default;
}
.cssbutton:disabled:hover {
	color: #b7b7b7;
	background: #f4f4f4;
	cursor: default;
}
.cssbox {
	-webkit-border-radius: 15px;
	-moz-border-radius: 15px;
	border-radius: 15px;
	font-size: medium;
	padding: 15px;
	text-decoration: none;
	width: 100%;
	-webkit-appearance: none;
	box-sizing: border-box;
	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	-webkit-box-shadow: none;
	-moz-box-shadow: none;
	box-shadow: none;
	color: #000000;
	background: #ffffee;
	border: 1px solid #D3D3D3;
	overflow: auto;
}
input[type=radio] {
	/* Larger radio buttons */
	-ms-transform: scale(1.7); /* IE */
	-moz-transform: scale(1.7); /* FF */
	-webkit-transform: scale(1.7); /* Safari and Chrome */
	-o-transform: scale(1.7); /* Opera */
	padding: 0px;
	cursor: pointer;
	border: 1px solid #eeeeee;
}
</style>

<!--Now the JavaScript code-->
<script>
var	base26 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	base26B = base26,								//for scrambled alphabet
	base26BArray = new Array(26),					//this contains only the indices, as an array
	base26Binverse = new Array(26);				//for the inverse lookup

//makes the scrambled alphabet, starting from a string
function makeAlphabet(string){
	string = string.removeDiacritics().toUpperCase().replace(/[^A-Z]/g,'');
	var result = '', alpha = "ZYXWVUTSRQPONMLKJIHGFEDCBA";
	for(var i = 0; i < string.length; i++){
		if(result.indexOf(string[i]) == -1){
			result += string[i];
			var reg = new RegExp(string[i]);
			alpha = alpha.replace(reg,'');
		}
	}
	if(result){base26B = result + alpha}else{base26B = base26};
	for(var i = 0; i < 26; i++){
		base26BArray[i] = base26.indexOf(base26B.charAt(i));
		base26Binverse[i] = base26B.indexOf(base26.charAt(i))
	}
	alphabet.innerHTML = base26B.split('').join(' ');
	fillTabula()
}

//fills the Tabula Recta according to the scrambled alphabet
function fillTabula(){
	var straightTabula = "---------------------------------------------------\na | A B C D E F G H I J K L M N O P Q R S T U V W X Y Z | a\nb | B C D E F G H I J K L M N O P Q R S T U V W X Y Z A | b\nc | C D E F G H I J K L M N O P Q R S T U V W X Y Z A B | c\nd | D E F G H I J K L M N O P Q R S T U V W X Y Z A B C | d\ne | E F G H I J K L M N O P Q R S T U V W X Y Z A B C D | e\nf | F G H I J K L M N O P Q R S T U V W X Y Z A B C D E | f\ng | G H I J K L M N O P Q R S T U V W X Y Z A B C D E F | g\nh | H I J K L M N O P Q R S T U V W X Y Z A B C D E F G | h\ni | I J K L M N O P Q R S T U V W X Y Z A B C D E F G H | i\nj | J K L M N O P Q R S T U V W X Y Z A B C D E F G H I | j\nk | K L M N O P Q R S T U V W X Y Z A B C D E F G H I J | k\nl | L M N O P Q R S T U V W X Y Z A B C D E F G H I J K | l\nm | M N O P Q R S T U V W X Y Z A B C D E F G H I J K L | m\nn | N O P Q R S T U V W X Y Z A B C D E F G H I J K L M | n\no | O P Q R S T U V W X Y Z A B C D E F G H I J K L M N | o\np | P Q R S T U V W X Y Z A B C D E F G H I J K L M N O | p\nq | Q R S T U V W X Y Z A B C D E F G H I J K L M N O P | q\nr | R S T U V W X Y Z A B C D E F G H I J K L M N O P Q | r\ns | S T U V W X Y Z A B C D E F G H I J K L M N O P Q R | s\nt | T U V W X Y Z A B C D E F G H I J K L M N O P Q R S | t\nu | U V W X Y Z A B C D E F G H I J K L M N O P Q R S T | u\nv | V W X Y Z A B C D E F G H I J K L M N O P Q R S T U | v\nw | W X Y Z A B C D E F G H I J K L M N O P Q R S T U V | w\nx | X Y Z A B C D E F G H I J K L M N O P Q R S T U V W | x\ny | Y Z A B C D E F G H I J K L M N O P Q R S T U V W X | y\nz | Z A B C D E F G H I J K L M N O P Q R S T U V W X Y | z";
	for(var i=0; i < 26; i++){
		var reg = new RegExp(base26[i].toLowerCase(),"g");
		straightTabula = straightTabula.replace(reg,base26B[i])
	}
	tabula.innerText = straightTabula
}

//to remove accents etc.
String.prototype.removeDiacritics = function() {
    var diacritics = [
        [/[\300-\306]/g, 'A'],
        [/[\340-\346]/g, 'a'],
        [/[\310-\313]/g, 'E'],
        [/[\350-\353]/g, 'e'],
        [/[\314-\317]/g, 'I'],
        [/[\354-\357]/g, 'i'],
        [/[\322-\330]/g, 'O'],
        [/[\362-\370]/g, 'o'],
        [/[\331-\334]/g, 'U'],
        [/[\371-\374]/g, 'u'],
        [/[\321]/g, 'N'],
        [/[\361]/g, 'n'],
        [/[\307]/g, 'C'],
        [/[\347]/g, 'c'],
		 [/[\337]/g, 'ss'],
    ];
    var s = this;
    for (var i = 0; i < diacritics.length; i++) {
        s = s.replace(diacritics[i][0], diacritics[i][1]);
    }
    return s;
}

//processes plaintext and displays in box
function processPlain(){
	if(plainBox.value.trim() == '') return;
	var text = plainBox.value.replace(/[0-9]/g,function(match){return base26.charAt(match);}).trim();	//replace numbers with letters
	text = text.removeDiacritics();																	//remove accents and make upper case
	procPlainBox.innerHTML = text.toLowerCase().replace(/[^a-z]/g,'');								//final cleanup
	processKey();
}

var key, keyLength;
//processes key text and displays in box
function processKey(){
	key = keyBox.value.removeDiacritics().toUpperCase().replace(/[^A-Z]/g,'').trim();		//remove accents and make upper case
	keyLength = key.length;
	makeAlphabet(key);																			//make scrambled alphabet
	if(procPlainBox.innerHTML == '') return;													//stop if there is no plaintext
	
	makeCipher();
}

//calculates keystream from the key and the generated ciphertext
function makeCipher(){
	var text = procPlainBox.innerHTML.toUpperCase().trim(),
		length = text.length,
		outputTable = text,
		textArray = new Array(length),
		cipherArray = new Array(length);
	
	//now fill row 1 with numbers representing letters; this will be a lot fastter than doing string operations
	for(var i = 0; i < length; i++){
		textArray[i] = base26.indexOf(text.charAt(i))
	}

	//main calculation
	for(var i = 0; i < directBox.value ; i++){
		textArray = keyedLFG4(textArray);
		for(var j = 0; j < length; j++) cipherArray[j] = base26.charAt(textArray[j]);
		outputTable += '<br>' + cipherArray.join('')
	}
	for(var i = 0; i < reverseBox.value ; i++){
		textArray = reverseKeyedLFG4(textArray);
		for(var j = 0; j < length; j++) cipherArray[j] = base26.charAt(textArray[j]);
		outputTable += '<br>' + cipherArray.join('')
	}
	
	//convert back to base26	and display
	procKeyBox.innerHTML = '<pre>' + outputTable + '</pre>';
	var cipherText = cipherArray[0] ? cipherArray.join('') : text;
	cipherBox.innerHTML = cipherText;
	codeGroupBox.innerHTML = cipherText.match(/.{1,5}/g).join(' ');
	keyStreamQuality26(textArray)
}

//just for base26, uses base26BArray, base26Binverse
function keyedLFG4(array){
	var length = array.length,
		output = new Array(length);
	output[0] = array[length-1];
	output[1] = base26BArray[(26 - base26Binverse[array[0]] + output[0]) % 26];
	for(var i = 1; i < length - 1; i++){
		output[i+1] = base26BArray[(52 - array[i-1] + output[i-1] - base26Binverse[array[i]] + output[i]) % 26]
	}
	return output
}

//reversal of the above
function reverseKeyedLFG4(array){
	var length = array.length,
		output = new Array(length);
	output[length-1] = array[0];
	output[0] = base26BArray[(26 - base26Binverse[array[1]] + array[0]) % 26]; 
	for(var i = 1; i < length - 1; i++){
		output[i] = base26BArray[(52 - output[i-1] - base26Binverse[array[i+1]] + array[i] + array[i-1]) % 26]
	}
	return output
}

//displays quality of the base64 keystream. Performs five tests: single digit Chi-squared, Durbin-Watson (both compared to the uniform distribution), Shannon's entropy, runs test, and Chi-squared independence test at distances from 1 to 10
function keyStreamQuality26(array){
	frequencies(array,26);
	var chiNumber = chiSquared(array,26),
		chiResult = chiNumber.toString().slice(0,6);
	var	dwNumber = durbinWatson(array,26),
		dwResult = dwNumber.toString().slice(0,6);
	var	entropyNumber = shannonEntropy(array,26),
		entropyResult = entropyNumber.toString().slice(0,6);
	var	runsNumber = runs(array,26),
		runsResult = runsNumber.toString().slice(0,6);
	var ICnumber = coincidenceIndex(array,26),
		ICresult = ICnumber.toString().slice(0,6);
	if(indTest26.checked){
		var	corResult = corrAtDistance(array,26,1).toString().slice(0,6)
	}
	if(chiNumber > 34.4) chiResult = '<span style="color:red;">' + chiResult + '</span>';
	if(Math.abs(dwNumber - 2) > 0.1) dwResult = '<span style="color:red;">' + dwResult + '</span>';
	if(entropyNumber < 4.6) entropyResult = '<span style="color:red;">' + entropyResult + '</span>';
	if(Math.abs(runsNumber - 2) > 0.1) runsResult = '<span style="color:red;">' + runsResult + '</span>';
	if(ICnumber > 0.04 && ICnumber < 0.06){ICresult = '<span style="color:red;">' + ICresult + '</span>'}else if(ICnumber > 0.06){ICresult = '<span style="color:limegreen;">' + ICresult + '</span>'};

	qualityMsg.innerHTML = "Tests applied to the letter output with number of characters: " + array.length + "<br>Chi-squared (less than 34.4 is good) = " + chiResult + "<br>DW statistic (should be close to 2.0) = " + dwResult + "<br>Shannon's entropy (should approach 4.7) = " + entropyResult + "<br>Chars per run (should be close to 2.0) = " + runsResult + "<br>Index of coincidence (as low as 0.03846 for random, around 0.066 for English text) = " + ICresult;
	if(indTest26.checked) qualityMsg.innerHTML += "<br>Correlation Chi-squared of contiguous letters (should be below 671) = " + corResult;
}

var freqArray = [];				//used by a lot of the other functions, so might as well do the calculation just once
//counts frequency for each digit in the given base. The input array contains numbers from 0 to base - 1
function frequencies(array,base){
	var length = array.length;
	freqArray = new Array(base);
	for(var j = 0; j < base; j++) freqArray[j] = 0;
	for(var i = 0; i < length; i++) freqArray[array[i]]++
}

//chi-squared statistic of a array in a given base
function chiSquared(array,base){
	var	result = 0,
		length = array.length;
		expected = length / base,
		operand = 0;
	for(var i = 0; i < base; i++){
		operand = freqArray[i] - expected;
		result += (operand * operand) / expected
	}
	return result
}

//two-digit correlations at different distance, for a given base
function corrArray(array,base,maxShift){
	var	length = array.length,
		output = new Array(maxShift),
		data,result,operand,expected;	
	for(var l = 1; l <= maxShift; l++){			//for each shift, do a 2-character chi-squared
		result = 0;
		for(var i = 0; i < base; i++){					//each first character
			for(var j = 0; j < base; j++){				//each second character
				data = 0;
				expected = freqArray[i] * freqArray[j] / length;		//expected P(xy) = P(x)*P(y)
				if(expected > 0){										//in case a letter does not appear at all
					for(var k = 0; k < length-l; k++){
						if((array[k] == i) && (array[k+l] == j)) data++
					}
					operand = data - expected;
					result += (operand * operand) / expected
				}
			}
		}
		output[l-1] = result
	}
	return output
}

//as above but for a given distance. Minimum is 1. Could be large for distance = keylength + 2
function corrAtDistance(array,base,distance){
	var	length = array.length,
		highIndex = length - distance;
		data = 0,
		result = 0,
		operand = 0,
		expected = 0;
	for(var i = 0; i < base; i++){					//each first character
		for(var j = 0; j < base; j++){				//each second character
			data = 0;
			expected = freqArray[i] * freqArray[j] / length;		//expected P(xy) = P(x)*P(y)
			if(expected > 0){										//in case a letter does not appear at all
				for(var k = 0; k < highIndex; k++){
					if((array[k] == i) && (array[k + distance] == j)) data++
				}
				operand = data - expected;
				result += (operand * operand) / expected
			}
		}
	}
	return result
}

//computes the Durbin-Watson statistic for a sequence of consecutive digits that are expected to be random
function durbinWatson(array,base){
	var num = 0,
		denom = 0,
		length = array.length,
		operand = 0,
		subtrand = (base - 1) / 2;
	for(var i = 1; i < length; i++){
		operand = array[i] - array[i-1];
		num += operand * operand;
		operand = array[i] - subtrand;
		denom += operand * operand
	}
	return denom == 0 ? -1 : num/denom
}

//computes the entropy of a array of digits, in bits per digit
function shannonEntropy(array,base){
	var length = array.length,
		entropy = 0,
		frequency;
	for(var i = 0; i < base; i++){
		if(freqArray[i] != 0){
			frequency = freqArray[i] / length;
			entropy -= frequency * (Math.log(frequency) / Math.LN2);
		}
	}
	return entropy
}

//computes the number of binary digits per run, to see how correlated consecutive digits are (2.0 for true random) It assumes an even base, so it won't work for odd
function runs(array,base){
	var count = 0,
		large = false,
		largeOld = false,
		length = array.length,
		cutoff = (base - 1) / 2;
	for(var i = 0; i < length; i++){
		large = array[i] > cutoff;
		if(large != largeOld || i == 0) count++;
		largeOld = large;
	}
	return length / count
}

//computes Friedman's index of coincidence (IC)
function coincidenceIndex(array,base){
	var	length = array.length,
		result = 0;
	for(var i = 0; i < base; i++){
		result += freqArray[i]*(freqArray[i] - 1)
	}
	return result / (length * (length - 1))
}
</script>
</head>

<body>
<h1 align="center">Snakeacci encryption</h1>
<p align="center">&#169; Francisco Ruiz, 2016</p>
<p>This page simplifies the Worm cipher, by F. Ruiz, to minimize the amount of work without skimping on security. All steps can be performed by hand without excessive effort. Similar to Reversacci, but using four-letter &quot;snake&quot; operations to achieve near-randomness in only one step.</p>
<p>The basic idea is to perform a kind of Lagged Fibonacci Generator (LFG) using &quot;snake&quot; operations on a Tabula Recta that has a substitution built-in. The LFG takes care of removing bias in the output, while the snake &quot;sum&quot; involves four letters in order to further reduce bias and correlation. The substitution provides all the security, since the snake LFG operation is reversible by itself. Thus, reversing the snake LFG operation decrypts the message. This operation is not identical to that used in encryption, though similar (the letter pattern is different), and so the cipher is not reciprocal. In this implementation, the user can select an arbitrary number of encryption steps followed by an arbitrary number of decryption steps.</p>
<p>The first step is to generate a scrambled alphabet, which will serve as a substitution key and will be placed at the top and sides of the Tabula Recta used for the snake operations. The process is simple: 1, take the user-supplied text key and write down new letters in the other they appear; 2, then write the rest of the alphabet in reverse order.</p>
<p>After the plaintext or ciphertext is processed —spaces and punctuation are stripped, and all letters are converted to capitals; accented letters are replaced by their non-accented versions; numbers in plaintext are converted to letters as in 0=A,1=B,...9=J, but are not converted back— we perform &quot;snake sums&quot; using the Tabula Recta on groups of four letters (you'll see how the letters are chosen below), this way: find the first letter at the top and go down until the second letter is found, then left or right following that row until the third letter is found, then up or down on that column until the fourth letter is found, and then left or right to read off the result at the edge columns. Alternatively, you can start on the side rather than the top, switching direction every time a new letter is found, and read the result at the top. Now we discuss how to choose those letters for encryption and decryption.</p>
<p>Encryption, starting from the plaintext:</p>
<ol>
  <li>Take the last letter and write it below the first letter.</li>
  <li>Look up the top letter of these two on the top of the Tabula Recta, then go down until the bottom letter is found, then right or left and read off the letter at the edge; write it at the second position on the bottom row.</li>
  <li>From now on, the pattern for the snake operation described above will involve four letters, which form a square directly to the left of the spot to be filled, their position is given relative to this spot: first is top row, one space to the left of the spot to be filled; second is down from that one; third is top row, left of the first letter picked; fourth is down from that one. Do the snake operation with the letters in this order and write the result in the empty spot. Keep repeating this step while the bottom row is shorter than the top row. When done, the bottom row is the ciphertext.</li>
</ol>
<p>Decryption, starting from the ciphertext:</p>
<ol>
  <li>Take the first letter and write it below the last letter.</li>
  <li>Take the second letter of the ciphertext and look it up on the top of the Tabula Recta, then go down until the first ciphertext letter is found, then left or right and read off the letter at the edge; write it directly below the first ciphertext letter.</li>
  <li>From now on, the pattern for the snake operation described above will involve four letters, which form a kind of T over the spot to be filled; the post is directly to the left of it, and the crossbar is right above it: first is top row, one space to the right of the spot to be filled; second is directly left of that one; third is directly left of the spot to be filled, on the bottom row; fourth is one space up from that one, on the top row. Do the snake operation with the letters in this order and write the result in the empty spot. Keep repeating this step while the bottom row is shorter than the top row. When done, the bottom row is the plaintext.</li>
</ol>
<h3>Tabula Recta</h3>
<div align="center">
  <pre id="alphabet">
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  </pre>
  <pre id="tabula">---------------------------------------------------
A | A B C D E F G H I J K L M N O P Q R S T U V W X Y Z | A
B | B C D E F G H I J K L M N O P Q R S T U V W X Y Z A | B
C | C D E F G H I J K L M N O P Q R S T U V W X Y Z A B | C
D | D E F G H I J K L M N O P Q R S T U V W X Y Z A B C | D
E | E F G H I J K L M N O P Q R S T U V W X Y Z A B C D | E
F | F G H I J K L M N O P Q R S T U V W X Y Z A B C D E | F
G | G H I J K L M N O P Q R S T U V W X Y Z A B C D E F | G
H | H I J K L M N O P Q R S T U V W X Y Z A B C D E F G | H
I | I J K L M N O P Q R S T U V W X Y Z A B C D E F G H | I
J | J K L M N O P Q R S T U V W X Y Z A B C D E F G H I | J
K | K L M N O P Q R S T U V W X Y Z A B C D E F G H I J | K
L | L M N O P Q R S T U V W X Y Z A B C D E F G H I J K | L
M | M N O P Q R S T U V W X Y Z A B C D E F G H I J K L | M
N | N O P Q R S T U V W X Y Z A B C D E F G H I J K L M | N
O | O P Q R S T U V W X Y Z A B C D E F G H I J K L M N | O
P | P Q R S T U V W X Y Z A B C D E F G H I J K L M N O | P
Q | Q R S T U V W X Y Z A B C D E F G H I J K L M N O P | Q
R | R S T U V W X Y Z A B C D E F G H I J K L M N O P Q | R
S | S T U V W X Y Z A B C D E F G H I J K L M N O P Q R | S
T | T U V W X Y Z A B C D E F G H I J K L M N O P Q R S | T
U | U V W X Y Z A B C D E F G H I J K L M N O P Q R S T | U
V | V W X Y Z A B C D E F G H I J K L M N O P Q R S T U | V
W | W X Y Z A B C D E F G H I J K L M N O P Q R S T U V | W
X | X Y Z A B C D E F G H I J K L M N O P Q R S T U V W | X
Y | Y Z A B C D E F G H I J K L M N O P Q R S T U V W X | Y
Z | Z A B C D E F G H I J K L M N O P Q R S T U V W X Y | Z</pre>
</div>
<p>We are going to perform a special kind of addition (actually, a subtraction followed by a change of sign) using this table. To &quot;add&quot; two letters: find the first letter on the left or right side and follow that row until you find the second letter, then go up that column to read the result at the top row or you find the lext letter to &quot;added&quot;.  Examples with straight alphabet: R + H = Q, E + W + F = N, Z + A + J + X = P.</p>
<p>&nbsp;</p>
<h2>Step 1. Tabula preparation</h2>
<p>We begin by making a scrambled alphabet out of the key, which is then placed at the top of the Tabula Recta, and then repeated in the body itself. This is why we input the key before the plaintext.  The box is blue to indicate that it can be written on. Do this to make a scrambled alphabet: take the key and write the different letters of the alphabet at the top of the table in the order they appear in the key; if there are letters that did not appear in the key, write them now at the top of the table in reverse alphabetical order. Then take the same scrambled alphabet and write it on the side columns.</p>
<p>It is OK to  use a key that has been used before, even for a message of identical length as a previous message.</p>
<h3>Key</h3>
<textarea name="keyBox" class="cssbox" id="keyBox" style="font-size:larger;background-color:#E4F7FF;" title="Enter the key text taken from a book or whatever here" onKeyUp="processKey();"></textarea>
<p>Let us also decide how many direct &quot;snake LFG&quot; operations will be applied, and how many reversed ones following those (to decrypt, switch the numbers in the two boxes):</p>
<p> Direct snake LFG steps:
  <input type="text" id="directBox" style="font-size:larger;background-color:#E4F7FF;width:100px;" onKeyUp="makeCipher();" title="number of LFG+transposition steps" value="1">
  </input>
Allowed values are integers 0 to infinity.</p>
<p> Reversed snake LFG steps:
  <input type="text" id="reverseBox" style="font-size:larger;background-color:#E4F7FF;width:100px;" onKeyUp="makeCipher();" title="number of reversed transposition+LFG steps" value="0">
  </input>
  Allowed values are integers 0 to infinity.</p>
<p>&nbsp;</p>
<h2>Step 2. Plaintext preparation</h2>
<p>Now the message to be encrypted or decrypted.</p>
<h3>Plaintext / Ciphertext</h3>
<textarea name="plainBox" class="cssbox" id="plainBox" style="font-size:larger;background-color:#E4F7FF;" title="Enter your plaintext (or ciphertext, when decrypting) here" onKeyUp="processPlain();"></textarea>
Which is converted to this, after spaces, punctuation and diacritics are removed, and everything is turned into lowercase:
<h3>Processed Plaintext / Ciphertext</h3>
<div id="procPlainBox" class="cssbox" onKeyUp="" onPaste="" style="font-family:monospace;"></div>
<p>&nbsp;</p>
<h2>Step 3. Encryption / Decryption</h2>
<p>In order to obtain the ciphertext we generate the table below, following the instructions at the top of this page. The bottom row is the output.</p>
<h3>Work table</h3>
<div id="procKeyBox" class="cssbox" onKeyUp="" onPaste="" style="font-family:monospace;"></div>
<p>Some statistics will be displayed below this line. If you check the box at the end of this line, an additional *long* test will be performed &nbsp;&nbsp
<input type="checkbox" id="indTest26" title='include base26 independence test'/></p>
<p><span id="qualityMsg">Information about keystream randomness will appear here</span></p>
<p>&nbsp;</p>
<h2>Step 4. Encrypted Ciphertext / Decrypted Plaintext</h2>
<p>The ciphertext (plaintext when decrypting) is the first box below. The lower box contains the same, but split into codegroups of five characters each.</p>
<h3>Ciphertext / Plaintext</h3>
<div id="cipherBox" class="cssbox" style="background-color:#DCF2D1;"></div>
<h3>Formatted output</h3>
<div id="codeGroupBox" class="cssbox" style="background-color:#DCF2D1;font-family:monospace;font-size:larger;"></div>
</body>
</html>
